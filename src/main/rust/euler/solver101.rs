// COPYRIGHT (C) 2023 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use algorithm::cast::Cast;
use algorithm::root::pow;
use algorithm::vec::array_sum;
use Solver;

const INPUT_101: &[i64] = &[1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1];

/// If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.
/// As an example, let us consider the sequence of cube numbers. This is defined by the generating function `un = n^3: 1, 8, 27, 64, 125, 216, ...`
/// Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be `15` (common difference `7`). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
///
/// We shall define `OP(k, n)` to be the `nth` term of the optimum polynomial generating function for the first `k` terms of a sequence. It should be clear that `OP(k, n)` will accurately generate the terms of the sequence for `n ≤ k`, and potentially the first incorrect term (`FIT`) will be `OP(k, k+1)`; in which case we shall call it a bad OP (`BOP`).
/// As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for `n ≥ 2`, `OP(1, n) = u1`.
/// Hence we obtain the following `OP`s for the cubic sequence:
///
/// `OP(1, n) = 1`         `1, *1*, 1, 1, ...`
/// `OP(2, n) = 7n−6`      `1, 8, *15*, ...`
/// `OP(3, n) = 6n2−11n+6` `1, 8, 27, *58*, ...`
/// `OP(4, n) = n3`        `1, 8, 27, 64, 125, ...`
///
/// Clearly no `BOP`s exist for `k ≥ 4`.
///
/// By considering the sum of `FIT`s generated by the `BOP`s (indicated in red above), we obtain `1 + 15 + 58 = 74`.
///
/// Consider the following tenth degree polynomial generating function: `un = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10`
/// Find the sum of `FIT`s for the `BOP`s.
pub struct Solver101 {
    pub n: i64,
    pub input: Vec<i64>,
}

impl Default for Solver101 {
    fn default() -> Self {
        Self { n: 10, input: INPUT_101.to_vec() }
    }
}

impl Solver for Solver101 {
    fn solve(&self) -> i64 {
        let poly_evaluate = |poly: &[i64], n| poly.iter().enumerate().filter(|(_, &c)| c != 0).map(|(exp, c)| c * pow(n, (poly.len() - exp - 1).as_i64())).sum::<i64>();

        // uses finite differences to calculate the first FIT https://en.wikipedia.org/wiki/Finite_difference#Application
        // the sum of the FITs in all levels is actually the sum of the finite differences
        let (mut sum, mut sequence) = (0, (1..=self.n).map(|i| poly_evaluate(&self.input, i)).collect::<Vec<_>>());

        while !sequence.is_empty() {
            sum += array_sum(&sequence);
            sequence = (0..sequence.len() - 1).map(|i| sequence[i+1] - sequence[i]).collect();
        }
        sum
    }
}
