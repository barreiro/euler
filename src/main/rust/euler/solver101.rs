// COPYRIGHT (C) 2023 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use algorithm::cast::Cast;
use algorithm::root::pow;
use algorithm::vec::array_sum;
use Solver;

// const INPUT_101: &[f64] = &[1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0];
const INPUT_101: &[i64] = &[1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1];

/// If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.
/// As an example, let us consider the sequence of cube numbers. This is defined by the generating function `un = n^3: 1, 8, 27, 64, 125, 216, ...`
/// Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be `15` (common difference `7`). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
///
/// We shall define `OP(k, n)` to be the `nth` term of the optimum polynomial generating function for the first `k` terms of a sequence. It should be clear that `OP(k, n)` will accurately generate the terms of the sequence for `n ≤ k`, and potentially the first incorrect term (`FIT`) will be `OP(k, k+1)`; in which case we shall call it a bad OP (`BOP`).
/// As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for `n ≥ 2`, `OP(1, n) = u1`.
/// Hence we obtain the following `OP`s for the cubic sequence:
///
/// `OP(1, n) = 1`         `1, *1*, 1, 1, ...`
/// `OP(2, n) = 7n−6`      `1, 8, *15*, ...`
/// `OP(3, n) = 6n2−11n+6` `1, 8, 27, *58*, ...`
/// `OP(4, n) = n3`        `1, 8, 27, 64, 125, ...`
///
/// Clearly no `BOP`s exist for `k ≥ 4`.
///
/// By considering the sum of `FIT`s generated by the `BOP`s (indicated in red above), we obtain `1 + 15 + 58 = 74`.
///
/// Consider the following tenth degree polynomial generating function: `un = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10`
/// Find the sum of `FIT`s for the `BOP`s.
pub struct Solver101 {
    pub n: i64,
    pub input: Vec<i64>,
}

impl Default for Solver101 {
    fn default() -> Self {
        Self { n: 10, input: INPUT_101.to_vec() }
    }
}

impl Solver for Solver101 {
    fn solve(&self) -> i64 {
        // let poly_evaluate = |poly: &[f64], n: f64| {
        //     poly.iter().enumerate().filter(|(_, &c)| c != 0.0).map(|(exp, c)| c * n.powi((poly.len() - exp - 1) as i32)).sum::<f64>()
        // };
        //
        // let sequence = (1..=self.n).map(|i| poly_evaluate(&self.input, i as _)).collect::<Vec<_>>();
        //
        // let first_incorrect_term = |n: usize| {
        //     // Polynomial interpolation from the first n terms of the sequence, using gauss elimination on the Vandermonde matrix
        //     // see https://en.wikipedia.org/wiki/Polynomial_interpolation#Second_proof
        //     let mut optimum = gauss_elimination((1..=n).map(|i| (0..n).map(|n| i.pow(n as _) as f64).collect::<Vec<_>>()).collect::<Vec<_>>(), &sequence[0..n]);
        //     optimum.reverse();
        //     poly_evaluate(&optimum, (n + 1) as f64)
        // };
        //
        // (1..=self.n).map(|n| first_incorrect_term(n).round().as_i64()).sum()

        let poly_evaluate = |poly: &[i64], n| poly.iter().enumerate().filter(|(_, &c)| c != 0).map(|(exp, c)| c * pow(n, (poly.len() - exp - 1).as_i64())).sum::<i64>();

        // uses finite differences to calculate the first FIT https://en.wikipedia.org/wiki/Finite_difference#Application
        // the sum of the FITs in all levels is actually the sum of the finite differences
        let (mut sum, mut sequence) = (0, (1..=self.n).map(|i| poly_evaluate(&self.input, i)).collect::<Vec<_>>());

        while !sequence.is_empty() {
            sum += array_sum(&sequence);
            sequence = (0..sequence.len() - 1).map(|i| sequence[i+1] - sequence[i]).collect();
        }
        sum
    }
}

// --- //

fn _gauss_elimination(mut matrix: Vec<Vec<f64>>, solution: &[f64]) -> Vec<f64> {
    let dim = matrix.len();
    (0..dim).for_each(|c| matrix[c].push(solution[c]));

    // FORWARD ELIMINATION: reduce every element under diagonal to 0.0
    (0..dim).for_each(|c| {
        // PIVOTING: find the max value in column and swap rows. this stabilizes the algorithm
        let pivot = (c..dim).max_by(|&r1, &r2| matrix[r1][c].abs().partial_cmp(&matrix[r2][c].abs()).unwrap()).unwrap();
        matrix.swap(c, pivot);

        (c + 1..dim).for_each(|r| {
            let factor = matrix[r][c] / matrix[c][c];
            (c..=dim).for_each(|k| matrix[r][k] -= factor * matrix[c][k]);
        });
    });

    // REDUCTION: reduce elements over diagonal to 0.0. pivoting ensures last row is all 0.0
    (1..dim).rev().for_each(|c| {
        // optimization: only compute last column
        (0..c).rev().for_each(|r| matrix[r][dim] -= matrix[r][c] / matrix[c][c] * matrix[c][dim]);
        matrix[c][dim] /= matrix[c][c];
    });

    (0..dim).map(|c| matrix[c][dim]).collect()
}

