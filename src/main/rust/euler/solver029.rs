// COPYRIGHT (C) 2017 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use std::collections::HashSet;

use crate::algorithm::cast::Cast;
use crate::algorithm::long::GetAndIncrement;
use crate::algorithm::prime::prime_factors;
use crate::algorithm::root::{int_sqrt, pow, square};
use crate::Solver;

/// Consider all integer combinations of `a^b` for `2 ≤ a ≤ 5` and `2 ≤ b ≤ 5`:
/// ```
/// 2^2=4,  2^3=8,   2^4=16,  2^5=32
/// 3^2=9,  3^3=27,  3^4=81,  3^5=243
/// 4^2=16, 4^3=64,  4^4=256, 4^5=1024
/// 5^2=25, 5^3=125, 5^4=625, 5^5=3125
/// ```
/// If they are then placed in numerical order, with any repeats removed, we get the following sequence of `15` distinct terms: `4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125`
///
/// How many distinct terms are in the sequence generated by `a^b` for `2 ≤ a ≤ 100` and `2 ≤ b ≤ 100`?
pub struct Solver029 {
    pub n: i64,
}

impl Default for Solver029 {
    fn default() -> Self {
        Self { n: 100 }
    }
}

impl Solver for Solver029 {
    fn problem_name(&self) -> &str { "Distinct powers" }

    fn solve(&self) -> i64 {
        // the strategy is to find the combinations that generate duplicate powers and subtract it from the total number of combinations
        // a given number `2≤a≤N` can only produce duplicates if 'a^n' can be expressed as `(b^i)^j` with `n=i∗j` and `2≤n,i,j≤N`
        let (bound, mut unique) = (int_sqrt(self.n), HashSet::new());

        let factored_power = |base: i64, power| {
            let factors = prime_factors(base.as_u64());
            (factors.keys().product::<u64>().as_i64(), factors.values().product::<u64>().as_i64() * power / factors.len().as_i64())
        };

        square(self.n - 1) - (2..=bound).map(|b| (2..=bound).map(|i| (pow(b, i), i)).filter(|&(a, _)| a <= self.n && unique.insert(a)).map(|(a, i)| {
            let mut duplicates = (self.n / i) - 1;

            // the trivial duplicates that have `i*j<=N` are accounted. there may be an equivalent of the factorization that still satisfies the relation
            for j in 1 + self.n / i..self.n {
                let (factored_base, factored_exp) = factored_power(a, j);
                let (mut base, mut exp, mut k) = (factored_base, factored_exp, 2);
                while base < a {
                    if exp <= self.n && factored_exp % exp == 0 {
                        duplicates += 1;
                        break;
                    }
                    base *= factored_base;
                    exp = factored_exp / k.get_and_increment();
                }
            }
            duplicates
        }).sum::<i64>()).sum::<i64>()
    }
}
