// COPYRIGHT (C) 2017 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use std::collections::BTreeMap;
use std::convert::identity;
use std::ops::Range;

use euler::algorithm::long::{heptagonal, hexagonal, octagonal, pentagonal, pow_10, square, triangle};
use euler::Solver;

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
//
// Triangle    P(3,n) = n*(n+1)/2    1, 3, 6, 10, 15, ...
// Square      P(4,n) = n^2          1, 4, 9, 16, 25, ...
// Pentagonal  P(5,n) = n*(3*n−1)/2  1, 5, 12, 22, 35, ...
// Hexagonal   P(6,n) = n*(2*n−1)    1, 6, 15, 28, 45, ...
// Heptagonal  P(7,n) = n*(5*n−3)/2  1, 7, 18, 34, 55, ...
// Octagonal   P(8,n) = n*(3*n−2)    1, 8, 21, 40, 65, ...
//
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
//
// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
// Each polygonal type: triangle ( P(3,127) = 8128 ), square ( P(4,91) = 8281 ), and pentagonal ( P(5,44) = 2882 ), is represented by a different number in the set.
// This is the only set of 4-digit numbers with this property.
// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

const INPUT_061: &[fn(isize) -> isize] = &[triangle, square, pentagonal, hexagonal, heptagonal, octagonal];

pub struct Solver061 {
    pub n: isize,
    pub input: Vec<fn(isize) -> isize>,
}

impl Default for Solver061 {
    fn default() -> Self {
        Solver061 { n: 4, input: INPUT_061.to_vec() }
    }
}

impl Solver for Solver061 {
    fn solve(&self) -> isize {
        let (mut set, floor, ceil, scale) = (Vec::with_capacity(self.input.len()), pow_10(self.n - 1), pow_10(self.n), pow_10(self.n / 2));
        let map = self.input.iter().map(|f| (f, (1..).map(f).skip_while(|&y| y < floor).take_while(|&y| y < ceil).collect())).collect();
        find(map, floor..ceil, floor, scale, &mut set);
        set.iter().sum::<isize>()
    }
}

// require BTreeMap for consistency when testing ¯\_(ツ)_/¯
fn find(predicates: BTreeMap<&fn(isize) -> isize, Vec<isize>>, range: Range<isize>, floor: isize, scale: isize, set: &mut Vec<isize>) -> bool {
    if predicates.is_empty() {
        return set.last().unwrap() % scale == set.first().unwrap() / scale;
    }
    for (p, v) in &predicates {
        let (start, end) = (v.binary_search(&range.start).unwrap_or_else(identity), v.binary_search(&range.end).unwrap_or_else(identity));
        for &candidate in v[start..end].iter() {
            let (mut reduced_predicates, f) = (predicates.clone(), (candidate % scale) * scale);
            reduced_predicates.remove(p);
            set.push(candidate);
            if f > floor && find(reduced_predicates, f..f + scale, floor, scale, set) {
                return true;
            }
            set.pop();
        }
    }
    false
}
