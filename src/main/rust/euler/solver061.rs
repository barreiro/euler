// COPYRIGHT (C) 2017 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems


use std::collections::btree_map::BTreeMap;
use std::convert::identity;
use std::ops::Range;
use algorithm::cast::Cast;
use algorithm::filter::less_than;
use algorithm::long::{heptagonal, hexagonal, octagonal, pentagonal, triangle};
use algorithm::root::{pow_10, square};
use Solver;

const INPUT_061: &[fn(i64) -> i64] = &[triangle, square, pentagonal, hexagonal, heptagonal, octagonal];

/// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
///
/// `Triangle    P(3,n) = n*(n+1)/2    1, 3, 6, 10, 15, ...`
/// `Square      P(4,n) = n^2          1, 4, 9, 16, 25, ...`
/// `Pentagonal  P(5,n) = n*(3*n−1)/2  1, 5, 12, 22, 35, ...`
/// `Hexagonal   P(6,n) = n*(2*n−1)    1, 6, 15, 28, 45, ...`
/// `Heptagonal  P(7,n) = n*(5*n−3)/2  1, 7, 18, 34, 55, ...`
/// `Octagonal   P(8,n) = n*(3*n−2)    1, 8, 21, 40, 65, ...`
///
/// The ordered set of three `4-digit` numbers: `8128, 2882, 8281`, has three interesting properties.
///
/// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
/// Each polygonal type: triangle (`P(3,127) = 8128`), square (`P(4,91) = 8281`), and pentagonal (`P(5,44) = 2882`), is represented by a different number in the set.
/// This is the only set of `4-digit` numbers with this property.
/// Find the sum of the only ordered set of six cyclic `4-digit` numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
pub struct Solver061 {
    pub n: u64,
    pub input: Vec<fn(i64) -> i64>,
}

impl Default for Solver061 {
    fn default() -> Self {
        Self { n: 4, input: INPUT_061.to_vec() }
    }
}

impl Solver for Solver061 {
    fn solve(&self) -> i64 {
        let (mut set, floor, ceil, scale) = (Vec::with_capacity(self.input.len()), pow_10(self.n - 1).as_i64(), pow_10(self.n).as_i64(), pow_10(self.n / 2).as_i64());
        let map = self.input.iter().map(|f| (f, (1..).map(f).skip_while(less_than(floor)).take_while(less_than(ceil)).collect())).collect();
        find(&map, floor..ceil, floor, scale, &mut set);
        set.iter().sum()
    }
}

// require BTreeMap for consistency when testing ¯\_(ツ)_/¯
fn find(predicates: &BTreeMap<&fn(i64) -> i64, Vec<i64>>, range: Range<i64>, floor: i64, scale: i64, set: &mut Vec<i64>) -> bool {
    if predicates.is_empty() {
        return set.last().expect("Set should not be empty") % scale == set.first().expect("Set should not be empty") / scale;
    }
    for (p, v) in predicates {
        let (start, end) = (v.binary_search(&range.start).unwrap_or_else(identity), v.binary_search(&range.end).unwrap_or_else(identity));
        for &candidate in v[start..end].iter() {
            let (mut reduced_predicates, f) = (predicates.clone(), (candidate % scale) * scale);
            reduced_predicates.remove(p);
            set.push(candidate);
            if f > floor && find(&reduced_predicates, f..f + scale, floor, scale, set) {
                return true;
            }
            set.pop();
        }
    }
    false
}
