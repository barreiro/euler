// COPYRIGHT (C) 2017 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use std::collections::HashMap;
use std::convert::TryFrom;
use std::iter::{from_fn, once};

use algorithm::cast::Cast;
use algorithm::filter::less_than_u64;
use algorithm::long::{IncrementAndGet, pow_mod};
use algorithm::root::{ceil_sqrt_u64, floor_sqrt_u64, pow_u64};
use algorithm::vec::array_product_u64;

// Bases for the Miller-Rabin test
const MR_THRESHOLD: u64 = 4_759_123_141;
const MR_BASE_FAST: &[u64] = &[2, 7, 61];
const MR_BASE: &[u64] = &[2, 325, 9_375, 28_178, 450_775, 9_780_504, 1_795_265_022];

/// calculates the prime factors of a given number. The result is a map where the keys are primes and the values are the occurrences
#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub fn prime_factors(n: u64) -> HashMap<u64, u64> {
    raw_prime_factors(n, generator_trial_division())
}

/// calculates the prime factors of a given number with a prime cache that should go up to the sqrt of the value. The result is a map where the keys are primes and the values are the occurrences
#[must_use]
pub fn prime_factors_with_cache(n: u64, primes: &[u64]) -> HashMap<u64, u64> {
    raw_prime_factors(n, primes.iter().copied())
}

#[allow(clippy::cast_possible_truncation)]
fn raw_prime_factors(n: u64, primes: impl IntoIterator<Item=u64>) -> HashMap<u64, u64> {
    let (mut factor_map, mut value, small) = (HashMap::new(), n, u32::try_from(n).is_ok());
    for factor in primes {
        while if small { value as u32 % factor as u32 == 0 } else { value % factor == 0 } {
            value = if small { u64::from(value as u32 / factor as u32) } else { value / factor };
            factor_map.entry(factor).and_modify(|e| *e += 1).or_insert(1);
        }
        if factor > value {
            break;
        }
    }
    if value > 1 {
        factor_map.insert(value, 1);
    }
    factor_map
}

/// assemble from some prime factors
pub fn from_prime_factors(factors: impl IntoIterator<Item=(u64, u64)>) -> u64 {
    factors.into_iter().filter(|&(_, exp)| exp != 0).map(|(base, exp)| pow_u64(base, exp)).sum()
}

// --- //

/// iterator of the primes up to n (excluding n) using an half-sieve algorithm
pub fn primes_up_to(value: u64) -> impl Iterator<Item=u64> {
    // generator_trial_division().take_while(less_or_equal_than_u64(value))
    let (mut sieve, ceil) = (vec![true; 1 + value.as_usize() / 2], if value < 1000 { value.as_usize() / 4 } else { ceil_sqrt_u64(value).as_usize() });
    (1..ceil).for_each(|n| if sieve[n] {
        (3 * n + 1..=value.as_usize() / 2).step_by(2 * n + 1).for_each(|multiple| sieve[multiple] = false);
    });
    once(2).chain((1..value / 2).filter(move |&n| sieve[n.as_usize()]).map(|n| (2 * n + 1).as_u64()))
}

// --- //

/// provides an iterator of primes generated by the method of trial division
pub fn generator_trial_division() -> impl Iterator<Item=u64> {
    let (mut sieve, mut bound, mut bound_target) = (vec![], 1, 1);
    from_fn(move || {
        let next = match sieve.last() {
            None => { 2 }
            Some(2) => {
                sieve.clear();
                3
            }
            Some(&last) => { (last + 2..).step_by(2).find(|&candidate| prime_sieve_bound(candidate, &sieve, &mut bound, &mut bound_target)).unwrap_or_default() }
        };

        sieve.push(next);
        Some(next)
    })
}

/// iterator of the primes up to n (excluding n) using a sieve algorithm
pub fn primes_trial_division_up_to(value: u64) -> impl Iterator<Item=u64> {
    generator_trial_division().take_while(less_than_u64(value))
}

/// finds if none of the values in the sieve is a factor of value
#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub const fn prime_sieve(value: u64, sieve: &[u64]) -> bool {
    // change for const: prime_sieve_bound(n, sieve, &mut floor_sqrt(n), &mut isize::MAX.clone())
    let (mut i, ceil) = (0, floor_sqrt_u64(value));
    while i < sieve.len() && sieve[i] <= ceil {
        if if value <= u32::MAX as u64 { value as u32 % sieve[i] as u32 == 0 } else { value % sieve[i] == 0 } {
            return false;
        }
        i += 1;
    }
    true
}

// this function keeps track of search bound to avoid calculating the square root each time
#[allow(clippy::cast_possible_truncation)]
fn prime_sieve_bound(value: u64, sieve: &[u64], ceil: &mut u64, ceil_target: &mut u64) -> bool {
    if value > *ceil_target {
        *ceil_target = ceil.increment_and_get() * *ceil;
    }
    sieve.iter().take_while(|&factor| factor <= ceil).all(|&f| if u32::try_from(value).is_ok() { value as u32 % f as u32 != 0 } else { value % f != 0 })
}

// --- //

/// provides an iterator of primes generated by the method of trial division
pub fn generator_wheel() -> impl Iterator<Item=u64> {
    generator_custom_wheel(&[2, 3, 5, 7, 11])
}

/// iterator of the primes up to n (excluding n) using wheel factorization algorithm
pub fn primes_wheel_up_to(value: u64) -> impl Iterator<Item=u64> {
    generator_wheel().take_while(less_than_u64(value))
}

fn generator_custom_wheel(primes: &[u64]) -> impl Iterator<Item=u64> {
    let size = array_product_u64(primes);
    let buckets = (size..=1 + size * 2).filter_map(|n| primes.iter().all(|p| n % p != 0).then_some::<u64>(n - size)).collect::<Vec<_>>();
    let mut increments = vec![0; buckets.last().expect("Custom wheel should not be empty").as_usize()];
    (0..buckets.len() - 1).for_each(|i| increments[buckets[i].as_usize()] = buckets[i + 1] - buckets[i]);

    let (mut sieve, mut bound, mut bound_target) = (vec![], 1, 1);
    from_fn(move || {
        let next = match sieve.last() {
            None => { 2 }
            Some(2) => {
                sieve.clear();
                3
            }
            Some(&last) => {
                if last < size {
                    (last + 2..).step_by(2).find(|&candidate| prime_sieve_bound(candidate, &sieve, &mut bound, &mut bound_target)).expect("There should be a next prime")
                } else {
                    let (mut candidate, mut index) = (last, last % size);
                    loop {
                        if let Some(&increment) = increments.get(index.as_usize()) {
                            candidate += increment;
                            if prime_sieve_bound(candidate, &sieve, &mut bound, &mut bound_target) {
                                break candidate;
                            }
                            index += increment;
                            if index > size { index = 1 }
                        }
                    }
                }
            }
        };

        sieve.push(next);
        Some(next)
    })
}

// --- //

/// provides an iterator of prime numbers, starting with the one below N
pub fn descending_primes(value: u64) -> impl Iterator<Item=u64> {
    let mut n = (value - 1) | 1;
    from_fn(move || loop {
        if n == 1 {
            return None;
        }
        n -= 2;
        if miller_rabin(n) {
            return if n > 1 { Some(n) } else { None };
        } else if n == 1 {
            return Some(2);
        }
    })
}

// --- //

/// provides an iterator for primoral numbers, the product of the smallest primes
pub fn primorals() -> impl Iterator<Item=u64> {
    let (mut generator, mut product) = (generator_trial_division(), 1);
    from_fn(move || {
        product *= generator.next().unwrap_or_default();
        Some(product)
    })
}

// --- //

/// quick test to find out if an arbitrary value is prime
#[must_use]
pub const fn miller_rabin(value: u64) -> bool {
    // changed to const: value != 1 && if value < MR_THRESHOLD { MR_BASE_FAST } else { MR_BASE }.iter().all(|&b| value <= b || miller_rabin_pass(b, value))
    let base = if value < MR_THRESHOLD { MR_BASE_FAST } else { MR_BASE };
    let mut i = base.len();
    while i > 0 {
        i -= 1;
        if value > base[i] && !miller_rabin_pass(base[i], value) {
            return false;
        }
    }
    value != 1
}

const fn miller_rabin_pass(base: u64, value: u64) -> bool {
    let s = (value - 1).trailing_zeros();
    let d = (value - 1) >> s;
    let mut a = pow_mod(base, d, value);
    let mut iteration = s as i64 - 1;

    if a == 1 {
        return true;
    }
    while iteration > 0 {
        iteration -= 1;

        if a == value - 1 {
            return true;
        }
        if a == 1 {
            return false;
        }
        a = pow_mod(a, 2, value);
    }
    a == value - 1
}
