// COPYRIGHT (C) 2017 barreiro. All Rights Reserved.
// Rust solvers for Project Euler problems

use std::collections::HashMap;

use euler::algorithm::long::{floor_sqrt, is_even};
use euler::algorithm::long::power_modulo;

// Bases for the Miller-Rabin test
const MR_THRESHOLD: isize = 4_759_123_141;
const MR_BASE_FAST: &[isize] = &[2, 7, 61];
const MR_BASE: &[isize] = &[2, 325, 9_375, 28_178, 450_775, 9_780_504, 1_795_265_022];

/// calculates the prime factors of a given number. The result is a map where the keys are primes and the values are the occurrences
pub fn prime_factors(n: isize) -> HashMap<isize, isize> {
    let (mut factor_map, mut value, small, stop) = (HashMap::new(), n, n <= i32::MAX as _, floor_sqrt(n));
    for factor in generator_trial_division() {
        while if small { value as i32 % factor as i32 == 0 } else { value % factor == 0 } {
            value = if small { (value as i32 / factor as i32) as _ } else { value / factor };
            factor_map.entry(factor).and_modify(|e| *e += 1).or_insert(1);
        }
        if value == 1 {
            break;
        }
        if factor >= stop {
            // the number is prime or if there is still a remainder, add it as a factor
            factor_map.insert(value, 1);
            break;
        }
    }
    factor_map
}

// --- //

/// provides an iterator of primes generated by the method of trial division
pub fn generator_trial_division() -> impl Iterator<Item=isize> {
    GeneratorTrialDivision { sieve: vec![], bound: 1, bound_target: 1 }
}

/// iterator of the primes up to n (excluding n) using trial division algorithm
pub fn primes_up_to(value: isize) -> impl Iterator<Item=isize> {
    GeneratorTrialDivision { sieve: vec![], bound: 1, bound_target: 1 }.take_while(move |&p| p <= value)
}

struct GeneratorTrialDivision {
    sieve: Vec<isize>,
    bound: isize,
    bound_target: isize,
}

impl Iterator for GeneratorTrialDivision {
    type Item = isize;

    fn next(&mut self) -> Option<Self::Item> {
        let next = match self.sieve.last() {
            None => { 2 }
            Some(2) => {
                self.sieve.clear();
                3
            }
            Some(&last) => { (last + 2..).step_by(2).find(|&candidate| prime_sieve_bound(candidate, &self.sieve, &mut self.bound, &mut self.bound_target)).unwrap() }
        };

        self.sieve.push(next);
        Some(next)
    }
}

/// finds if none of the values in the sieve is a factor of value
pub const fn prime_sieve(value: isize, sieve: &[isize]) -> bool {
    // change for const: prime_sieve_bound(n, sieve, &mut floor_sqrt(n), &mut isize::MAX.clone())
    let (mut i, ceil) = (0, floor_sqrt(value));
    while i < sieve.len() && sieve[i] <= ceil {
        if if value <= i32::MAX as _ { value as i32 % sieve[i] as i32 == 0 } else { value % sieve[i] == 0 } {
            return false;
        }
        i += 1;
    }
    true
}

// this function keeps track of search bound to avoid calculating the square root each time
fn prime_sieve_bound(value: isize, sieve: &[isize], ceil: &mut isize, ceil_target: &mut isize) -> bool {
    if value > *ceil_target {
        *ceil += 1;
        *ceil_target = *ceil * *ceil;
    }
    sieve.iter().take_while(|&factor| factor <= ceil).all(|&f| if value <= i32::MAX as _ { value as i32 % f as i32 != 0 } else { value % f != 0 })
}

// --- //

/// provides an iterator of primes generated by the method of trial division
pub fn generator_wheel() -> impl Iterator<Item=isize> {
    generator_custom_wheel(&[2, 3, 5, 7, 11])
}

fn generator_custom_wheel(primes: &[isize]) -> impl Iterator<Item=isize> {
    let size = primes.iter().product();
    let buckets = (size..=1 + size * 2).filter(|n| primes.iter().all(|p| n % p != 0)).map(|n| (n - size) as usize).collect::<Vec<_>>();
    let mut increments = vec![0; *buckets.last().unwrap()];
    (0..buckets.len() - 1).for_each(|i| increments[buckets[i]] = buckets[i + 1] - buckets[i]);
    GeneratorWheel { size: size as usize, increments, sieve: vec![], bound: 1, bound_target: 1 }
}

/// iterator of the primes up to n (excluding n) using wheel factorization algorithm
pub fn primes_wheel_up_to(value: isize) -> impl Iterator<Item=isize> {
    generator_wheel().take_while(move |&p| p < value)
}

struct GeneratorWheel {
    size: usize,
    increments: Vec<usize>,
    sieve: Vec<isize>,
    bound: isize,
    bound_target: isize,
}

impl Iterator for GeneratorWheel {
    type Item = isize;

    fn next(&mut self) -> Option<Self::Item> {
        let next = match self.sieve.last() {
            None => { 2 }
            Some(2) => {
                self.sieve.clear();
                3
            }
            Some(&last) => {
                if last < self.size as isize {
                    (last + 2..).step_by(2).find(|&candidate| prime_sieve_bound(candidate, &self.sieve, &mut self.bound, &mut self.bound_target)).unwrap()
                } else {
                    let (mut candidate, mut index) = (last, (last as usize) % self.size);
                    loop {
                        if let Some(&increment) = self.increments.get(index) {
                            candidate += increment as isize;
                            if prime_sieve_bound(candidate, &self.sieve, &mut self.bound, &mut self.bound_target) {
                                break candidate;
                            }
                            index += increment;
                            if index > self.size { index = 1 }
                        }
                    }
                }
            }
        };

        self.sieve.push(next);
        Some(next)
    }
}

// --- //

/// provides an iterator of prime numbers, starting with the one below N
pub fn descending_primes(value: isize) -> impl Iterator<Item=isize> {
    DescendingPrimes { n: if is_even(value) { value - 1 } else { value } }
}

struct DescendingPrimes {
    pub n: isize,
}

impl Iterator for DescendingPrimes {
    type Item = isize;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            self.n -= 2;
            if miller_rabin(self.n) {
                return if self.n > 1 { Some(self.n) } else { None };
            } else if self.n == 1 {
                return Some(2);
            }
        }
    }
}

// --- //

/// provides an iterator for primoral numbers, the product of the smallest primes
pub fn primorals() -> impl Iterator<Item=isize> {
    Primorals { generator: Box::new(generator_trial_division()), product: 1 }
}

struct Primorals {
    generator: Box<dyn Iterator<Item=isize>>,
    product: isize,
}

impl Iterator for Primorals {
    type Item = isize;

    fn next(&mut self) -> Option<Self::Item> {
        self.generator.next().map(|next| {
            self.product *= next;
            self.product
        })
    }
}

// --- //

/// quick test to find out if an arbitrary value is prime
pub const fn is_prime(value_ptr: &isize) -> bool {
    miller_rabin(*value_ptr)
}

/// quick test to find out if an arbitrary value is prime
pub const fn miller_rabin(value: isize) -> bool {
    // changed to const: value != 1 && if value < MR_THRESHOLD { MR_BASE_FAST } else { MR_BASE }.iter().all(|&b| value <= b || miller_rabin_pass(b, value))
    let base = if value < MR_THRESHOLD { MR_BASE_FAST } else { MR_BASE };
    let mut i = base.len();
    while i > 0 {
        i -= 1;
        if value > base[i] && !miller_rabin_pass(base[i], value) {
            return false;
        }
    }
    value != 1
}

const fn miller_rabin_pass(base: isize, value: isize) -> bool {
    let s = (value - 1).trailing_zeros() as isize;
    let d = (value - 1) >> s;
    let mut a = power_modulo(base, d, value);
    let mut iteration = s - 1;

    if a == 1 {
        return true;
    }
    while iteration > 0 {
        iteration -= 1;

        if a == value - 1 {
            return true;
        }
        if a == 1 {
            return false;
        }
        a = power_modulo(a, 2, value);
    }
    a == value - 1
}
